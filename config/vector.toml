# Vector configuration for Docker environment
# High-performance log ingestion and transformation

[api]
enabled = true
address = "0.0.0.0:8686"

[sources.system_logs]
type = "file"
include = ["/var/log/lastday.log"]
read_from = "beginning"
max_line_bytes = 1048576  # 1MB max line size

[sources.real_time_logs]
type = "file"
include = ["/var/log/app_logs/*.log"]
read_from = "end"
max_line_bytes = 1048576

[transforms.parse_logs]
type = "remap"
inputs = ["system_logs", "real_time_logs"]
source = '''
# Parse macOS system log format
# Format: Timestamp Thread Type Activity PID TTL Source: Message
if exists(.message) {
    parsed = parse_regex!(.message, r'^(?P<timestamp>\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d+\\+\\d{4})\\s+(?P<thread_id>\\S+)\\s+(?P<log_type>\\S+)\\s+(?P<activity_id>\\S+)\\s+(?P<pid>\\d+)\\s+(?P<ttl>\\d+)\\s+(?P<source>\\S+):\\s*(?P<log_message>.*)$')
    
    if exists(parsed) {
        .timestamp = parsed.timestamp
        .thread_id = parsed.thread_id
        .log_type = parsed.log_type
        .activity_id = parsed.activity_id
        .pid = to_int!(parsed.pid)
        .ttl = to_int!(parsed.ttl)
        .source = parsed.source
        .message = parsed.log_message
        
        # Determine log level
        message_lower = downcase(.message)
        if includes(message_lower, "error") || includes(message_lower, "failed") || includes(message_lower, "failure") {
            .level = "error"
        } else if includes(message_lower, "warning") || includes(message_lower, "warn") {
            .level = "warning"
        } else if includes(message_lower, "debug") || includes(message_lower, "trace") {
            .level = "debug"
        } else {
            .level = "info"
        }
        
        # Add Unix timestamp for ClickHouse
        .timestamp_unix = to_timestamp!(.timestamp, format: "%Y-%m-%d %H:%M:%S.%f%z")
        
        # Add metadata
        .metadata = {
            "file_path": .file,
            "line_number": .line_number,
            "parsed_at": now()
        }
    } else {
        # If parsing fails, mark as unparsed
        .level = "unknown"
        .parsed = false
    }
}
'''

[transforms.filter_valid_logs]
type = "filter"
inputs = ["parse_logs"]
condition = 'exists(.timestamp) && .level != "unknown"'

[transforms.add_metadata]
type = "remap"
inputs = ["filter_valid_logs"]
source = '''
# Add additional metadata
.host = get_hostname!()
.processor = "vector"
.ingestion_time = now()
'''

[sinks.clickhouse_logs]
type = "clickhouse"
inputs = ["add_metadata"]
endpoint = "http://clickhouse:8123"
database = "system_logs"
table = "logs"
compression = "gzip"
batch.max_events = 1000
batch.timeout_secs = 5

[sinks.console_debug]
type = "console"
inputs = ["add_metadata"]
encoding.codec = "json"
target = "stdout"

[sinks.file_errors]
type = "file"
inputs = ["add_metadata"]
path = "/var/log/vector_errors.log"
encoding.codec = "json"
compression = "gzip"
buffer.type = "memory"
buffer.max_events = 1000
buffer.when_full = "drop_newest"
